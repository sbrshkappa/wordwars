{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///Users/sbrsh/Code/wordwars/frontend/src/shared/dictionaryService.ts"],"sourcesContent":["// Free Dictionary API endpoint (for getWordDefinition only)\nconst DICTIONARY_API_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en';\n\nexport interface DictionaryResponse {\n  word: string;\n  phonetic?: string;\n  phonetics: Array<{\n    text?: string;\n    audio?: string;\n  }>;\n  meanings: Array<{\n    partOfSpeech: string;\n    definitions: Array<{\n      definition: string;\n      example?: string;\n    }>;\n  }>;\n}\n\nexport interface DictionaryError {\n  title: string;\n  message: string;\n  resolution: string;\n}\n\n// Check if a word exists in the dictionary (calls our API route)\nexport async function isValidDictionaryWord(word: string): Promise<boolean> {\n  try {\n    const res = await fetch(`/api/validate-word?word=${encodeURIComponent(word)}`);\n    const data = await res.json();\n    return !!data.valid;\n  } catch (e) {\n    // Fail open\n    return true;\n  }\n}\n\n// Get detailed information about a word (still uses axios)\nimport axios from 'axios';\nexport async function getWordDefinition(word: string): Promise<DictionaryResponse | null> {\n  try {\n    const response = await axios.get<DictionaryResponse[]>(`${DICTIONARY_API_URL}/${word.toLowerCase()}`);\n    return response.status === 200 && response.data.length > 0 ? response.data[0] : null;\n  } catch (error) {\n    if (axios.isAxiosError(error) && error.response?.status === 404) {\n      return null;\n    }\n    console.warn('Dictionary API error:', error);\n    return null;\n  }\n}\n\n// Cache for dictionary lookups to avoid repeated API calls\nconst wordCache = new Map<string, { isValid: boolean; timestamp: number }>();\nconst CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours\n\n// Cached version of word validation\nexport async function isValidDictionaryWordCached(word: string): Promise<boolean> {\n  const now = Date.now();\n  const cached = wordCache.get(word.toLowerCase());\n  \n  // Return cached result if it's still valid\n  if (cached && (now - cached.timestamp) < CACHE_DURATION) {\n    return cached.isValid;\n  }\n  \n  // Fetch from API and cache the result\n  const isValid = await isValidDictionaryWord(word);\n  wordCache.set(word.toLowerCase(), { isValid, timestamp: now });\n  \n  return isValid;\n}\n\n// Clear the cache (useful for testing or if cache gets too large)\nexport function clearDictionaryCache(): void {\n  wordCache.clear();\n}\n\n// Get cache statistics\nexport function getDictionaryCacheStats(): { size: number; entries: string[] } {\n  return {\n    size: wordCache.size,\n    entries: Array.from(wordCache.keys())\n  };\n} "],"names":[],"mappings":"AAAA,4DAA4D;;;;;;;;AAqC5D,2DAA2D;AAC3D;AArCA,MAAM,qBAAqB;AAyBpB,eAAe,sBAAsB,IAAY;IACtD,IAAI;QACF,MAAM,MAAM,MAAM,MAAM,CAAC,wBAAwB,EAAE,mBAAmB,OAAO;QAC7E,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,OAAO,CAAC,CAAC,KAAK,KAAK;IACrB,EAAE,OAAO,GAAG;QACV,YAAY;QACZ,OAAO;IACT;AACF;;AAIO,eAAe,kBAAkB,IAAY;IAClD,IAAI;QACF,MAAM,WAAW,MAAM,qIAAA,CAAA,UAAK,CAAC,GAAG,CAAuB,GAAG,mBAAmB,CAAC,EAAE,KAAK,WAAW,IAAI;QACpG,OAAO,SAAS,MAAM,KAAK,OAAO,SAAS,IAAI,CAAC,MAAM,GAAG,IAAI,SAAS,IAAI,CAAC,EAAE,GAAG;IAClF,EAAE,OAAO,OAAO;QACd,IAAI,qIAAA,CAAA,UAAK,CAAC,YAAY,CAAC,UAAU,MAAM,QAAQ,EAAE,WAAW,KAAK;YAC/D,OAAO;QACT;QACA,QAAQ,IAAI,CAAC,yBAAyB;QACtC,OAAO;IACT;AACF;AAEA,2DAA2D;AAC3D,MAAM,YAAY,IAAI;AACtB,MAAM,iBAAiB,KAAK,KAAK,KAAK,MAAM,WAAW;AAGhD,eAAe,4BAA4B,IAAY;IAC5D,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,SAAS,UAAU,GAAG,CAAC,KAAK,WAAW;IAE7C,2CAA2C;IAC3C,IAAI,UAAU,AAAC,MAAM,OAAO,SAAS,GAAI,gBAAgB;QACvD,OAAO,OAAO,OAAO;IACvB;IAEA,sCAAsC;IACtC,MAAM,UAAU,MAAM,sBAAsB;IAC5C,UAAU,GAAG,CAAC,KAAK,WAAW,IAAI;QAAE;QAAS,WAAW;IAAI;IAE5D,OAAO;AACT;AAGO,SAAS;IACd,UAAU,KAAK;AACjB;AAGO,SAAS;IACd,OAAO;QACL,MAAM,UAAU,IAAI;QACpB,SAAS,MAAM,IAAI,CAAC,UAAU,IAAI;IACpC;AACF","debugId":null}}]
}